<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metal-52 | Node {{ node_id }}</title>
    <style>
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #111827;
            --bg-tertiary: #1f2937;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --accent-primary: #10b981;
            --accent-danger: #ef4444;
            --accent-warning: #f59e0b;
            --border-color: #374151;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            --font-mono: 'Monaco', 'Menlo', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 2rem;
            height: calc(100vh - 40px);
        }

        .header {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            margin-bottom: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow);
        }

        .logo {
            font-family: var(--font-mono);
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .node-info {
            background: var(--bg-tertiary);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-family: var(--font-mono);
            font-size: 0.875rem;
            border: 1px solid var(--border-color);
        }

        .sidebar {
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            padding: 1.5rem;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }

        .main-area {
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow);
        }

        .section {
            margin-bottom: 2rem;
        }

        .section h3 {
            color: var(--accent-primary);
            margin-bottom: 1rem;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .status-item {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .status-item:hover {
            border-color: var(--accent-primary);
        }

        .status-value {
            display: block;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-primary);
            font-family: var(--font-mono);
        }

        .status-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .action-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .action-btn:hover {
            border-color: var(--accent-primary);
            background: var(--bg-primary);
            transform: translateY(-1px);
        }

        .action-btn.emergency:hover {
            border-color: var(--accent-danger);
            color: var(--accent-danger);
        }

        .action-icon {
            font-size: 1.5rem;
        }

        .btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-primary);
        }

        .btn-danger {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .chat-header {
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
            border-radius: 12px 12px 0 0;
        }

        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            min-height: 300px;
            max-height: 60vh;
        }

        .message {
            background: var(--bg-tertiary);
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border-left: 3px solid var(--accent-primary);
            animation: messageSlide 0.3s ease-out;
        }

        @keyframes messageSlide {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .system-message {
            background: var(--bg-primary);
            color: var(--text-muted);
            border-left-color: var(--text-muted);
            font-family: var(--font-mono);
            font-size: 0.875rem;
        }

        .chat-input {
            padding: 1rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 1rem;
            background: var(--bg-tertiary);
            border-radius: 0 0 12px 12px;
        }

        .chat-input input {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 1rem;
        }

        .chat-input input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.1);
        }

        .offline { color: var(--accent-danger); }
        .online { color: var(--accent-primary); }

        /* Media Panel */
        .media-panel {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            display: none;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            animation: panelSlide 0.3s ease-out;
        }

        @keyframes panelSlide {
            from { opacity: 0; transform: translateY(-50%) translateX(20px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }

        .media-panel.active {
            display: block;
        }

        .media-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .video-container {
            position: relative;
            margin-bottom: 1rem;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-tertiary);
        }

        #remoteVideo {
            width: 100%;
            height: 220px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            object-fit: cover;
        }

        #localVideo {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 75px;
            border: 2px solid var(--accent-primary);
            border-radius: 6px;
            background: var(--bg-primary);
            object-fit: cover;
            z-index: 10;
        }

        .media-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .media-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 1.25rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .media-btn:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        .media-btn.muted {
            background: var(--accent-danger);
            color: white;
        }

        /* Call Modal */
        .call-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .call-modal.active {
            display: flex;
            animation: modalFade 0.3s ease-out;
        }

        @keyframes modalFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .call-modal-content {
            background: var(--bg-secondary);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border-color);
            animation: modalPop 0.3s ease-out;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            min-width: 350px;
        }

        @keyframes modalPop {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .call-modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            justify-content: center;
        }

        .call-modal h2 {
            color: var(--accent-primary);
            margin-bottom: 1rem;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .sidebar {
                order: 2;
            }
            
            .main-area {
                order: 1;
            }
            
            .media-panel {
                width: calc(100% - 40px);
                max-width: 400px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            .action-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="logo">
                <span>üõ°Ô∏è</span>
                <span>METAL-52</span>
            </div>
            <div class="node-info">
                Node {{ node_id }} | {{ local_ip }}:{{ ports.web }}
            </div>
        </header>

        <aside class="sidebar">
            <div class="section">
                <h3>üåê Network Status</h3>
                <div class="status-grid">
                    <div class="status-item">
                        <span class="status-value" id="nodeId">{{ node_id }}</span>
                        <div class="status-label">Node ID</div>
                    </div>
                    <div class="status-item">
                        <span class="status-value" id="peerCount">0</span>
                        <div class="status-label">Peers</div>
                    </div>
                    <div class="status-item">
                        <span class="status-value">{{ ports.udp }}</span>
                        <div class="status-label">UDP Port</div>
                    </div>
                    <div class="status-item">
                        <span class="status-value online" id="status">ONLINE</span>
                        <div class="status-label">Status</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>‚ö° Quick Actions</h3>
                <div class="action-grid">
                    <button class="action-btn" onclick="startAudioCall()">
                        <span class="action-icon">üé§</span>
                        <span>Voice Call</span>
                    </button>
                    <button class="action-btn" onclick="startVideoCall()">
                        <span class="action-icon">üìπ</span>
                        <span>Video Call</span>
                    </button>
                    <button class="action-btn" onclick="sendFile()">
                        <span class="action-icon">üìÅ</span>
                        <span>Send File</span>
                    </button>
                    <button class="action-btn emergency" onclick="emergencyStop()">
                        <span class="action-icon">‚ö†Ô∏è</span>
                        <span>Emergency</span>
                    </button>
                </div>
            </div>
        </aside>

        <main class="main-area">
            <div class="chat-header">
                <h2>üîí Secure Communication</h2>
                <div>
                    <button class="btn" onclick="clearChat()">üóëÔ∏è Clear</button>
                    <button class="btn" onclick="exportChat()">üíæ Export</button>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="message system-message">
                    <strong>[SYSTEM]</strong> Metal-52 Node {{ node_id }} initialized
                </div>
            </div>

            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="Enter secure message..." maxlength="500" autocomplete="off">
                <button class="btn" onclick="sendMessage()">üì§ Send</button>
            </div>
        </main>
    </div>

    <!-- Media Panel -->
    <div id="mediaPanel" class="media-panel">
        <div class="media-header">
            <h3 style="margin: 0; color: var(--accent-primary);">üìû Call Active</h3>
            <button class="btn btn-danger" onclick="endCall()">End Call</button>
        </div>

        <div class="video-container">
            <video id="remoteVideo" 
                   autoplay 
                   playsinline 
                   muted="false"
                   style="width: 100%; height: 220px; background: var(--bg-tertiary); border-radius: 8px; object-fit: cover;">
                Your browser does not support video.
            </video>
            <video id="localVideo" 
                   autoplay 
                   playsinline 
                   muted="true"
                   style="position: absolute; top: 10px; right: 10px; width: 100px; height: 75px; 
                          border: 2px solid var(--accent-primary); border-radius: 6px; object-fit: cover;">
                Your browser does not support video.
            </video>
        </div>

        <div class="media-controls">
            <button id="muteBtn" class="media-btn" onclick="toggleMute()" title="Toggle Microphone">üé§</button>
            <button id="videoBtn" class="media-btn" onclick="toggleVideo()" title="Toggle Camera">üìπ</button>
            <button class="media-btn" onclick="shareScreen()" title="Share Screen">üñ•Ô∏è</button>
        </div>
    </div>

    <!-- Incoming Call Modal -->
    <div id="callModal" class="call-modal">
        <div class="call-modal-content">
            <h2 id="callModalTitle">üìû Incoming Call</h2>
            <p id="callModalMessage">Incoming call from Node-X</p>
            <div class="call-modal-buttons">
                <button class="btn btn-danger" onclick="declineCall()">üìµ Decline</button>
                <button class="btn" style="background: var(--accent-primary); color: var(--bg-primary);" onclick="acceptCall()">‚úÖ Accept</button>
            </div>
        </div>
    </div>

    <script>
        // =================================================================
        // GLOBAL CONFIGURATION
        // =================================================================
        
        const nodeConfig = {
            node_id: {{ node_id }},
            local_ip: "{{ local_ip }}",
            ports: {{ ports|tojson|safe }}
        };

        // =================================================================
        // WEBRTC IMPLEMENTATION - COMPLETE AND FIXED
        // =================================================================

        class Metal52WebRTC {
            constructor() {
                this.localStream = null;
                this.remoteStream = null;
                this.peerConnection = null;
                this.websocket = null;
                this.nodeId = {{ node_id }};
                this.localPeerId = `node-{{ node_id }}`;
                
                this.rtcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                };
                
                this.isCallActive = false;
                this.callType = null;
                this.pendingCall = null;
                this.isCaller = false;
                this.callEnded = false;
                this.signalingState = 'stable';
                
                console.log('[WebRTC] ‚úÖ Manager initialized for Node', this.nodeId);
            }
            
            setWebSocket(websocket) {
                this.websocket = websocket;
                console.log('[WebRTC] ‚úÖ WebSocket connected');
            }
            
            createPeerConnection() {
                // Close existing connection
                if (this.peerConnection) {
                    console.log('[WebRTC] üîÑ Closing existing peer connection');
                    this.peerConnection.close();
                }
                
                this.peerConnection = new RTCPeerConnection(this.rtcConfig);
                this.callEnded = false;
                
                // CRITICAL: ontrack handler MUST be set first (from search results)
                this.peerConnection.ontrack = (event) => {
                    console.log('[WebRTC] üéâ ONTRACK EVENT FIRED!');
                    console.log('[WebRTC] Event details:', {
                        streams: event.streams.length,
                        track: event.track.kind,
                        trackLabel: event.track.label
                    });
                    
                    if (event.streams && event.streams[0]) {
                        this.remoteStream = event.streams[0];
                        console.log('[WebRTC] ‚úÖ Remote stream received');
                        
                        // Immediate video assignment
                        this.assignRemoteVideo();
                    } else {
                        console.error('[WebRTC] ‚ùå No streams in ontrack event');
                    }
                };
                
                // ICE candidate handling
                this.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('[WebRTC] üì° Sending ICE candidate:', event.candidate.type);
                        this.sendSignalingMessage({
                            type: 'ice-candidate',
                            candidate: event.candidate,
                            from: this.localPeerId
                        });
                    } else {
                        console.log('[WebRTC] ‚úÖ ICE gathering complete');
                    }
                };
                
                // Connection state monitoring
                this.peerConnection.onconnectionstatechange = () => {
                    const state = this.peerConnection.connectionState;
                    console.log('[WebRTC] üîÑ Connection state:', state);
                    
                    switch (state) {
                        case 'connected':
                            console.log('[WebRTC] üéâ WEBRTC CONNECTED!');
                            addSystemMessage('üîó WebRTC connection established');
                            break;
                        case 'failed':
                            console.error('[WebRTC] ‚ùå Connection failed');
                            addSystemMessage('‚ùå Connection failed - retrying...');
                            break;
                        case 'disconnected':
                            console.warn('[WebRTC] ‚ö†Ô∏è Connection lost');
                            addSystemMessage('üìµ Connection lost');
                            break;
                    }
                };
                
                // ICE connection state
                this.peerConnection.oniceconnectionstatechange = () => {
                    console.log('[WebRTC] üßä ICE state:', this.peerConnection.iceConnectionState);
                };
                
                // Signaling state
                this.peerConnection.onsignalingstatechange = () => {
                    this.signalingState = this.peerConnection.signalingState;
                    console.log('[WebRTC] üì° Signaling state:', this.signalingState);
                };
                
                console.log('[WebRTC] ‚úÖ Peer connection created with all handlers');
            }
            
            // Enhanced video assignment with multiple fallbacks
            assignRemoteVideo() {
                const remoteVideo = document.getElementById('remoteVideo');
                if (!remoteVideo) {
                    console.error('[WebRTC] ‚ùå Remote video element not found');
                    return;
                }
                
                if (!this.remoteStream) {
                    console.error('[WebRTC] ‚ùå No remote stream to assign');
                    return;
                }
                
                console.log('[WebRTC] üì∫ Assigning remote stream to video element');
                
                // Method 1: Direct assignment (from search results)
                try {
                    remoteVideo.srcObject = this.remoteStream;
                    console.log('[WebRTC] ‚úÖ Stream assigned via srcObject');
                    
                    // Force play
                    const playPromise = remoteVideo.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('[WebRTC] üé• Remote video playing successfully!');
                            addSystemMessage('üìπ Remote video connected');
                        }).catch(error => {
                            console.error('[WebRTC] ‚ùå Video play failed:', error);
                            this.retryVideoAssignment(remoteVideo);
                        });
                    }
                } catch (error) {
                    console.error('[WebRTC] ‚ùå srcObject assignment failed:', error);
                    this.retryVideoAssignment(remoteVideo);
                }
            }
            
            // Retry mechanism for video assignment
            retryVideoAssignment(videoElement) {
                console.log('[WebRTC] üîÑ Retrying video assignment...');
                
                setTimeout(() => {
                    if (this.remoteStream && videoElement) {
                        videoElement.srcObject = null;
                        videoElement.load();
                        
                        setTimeout(() => {
                            videoElement.srcObject = this.remoteStream;
                            videoElement.play().then(() => {
                                console.log('[WebRTC] ‚úÖ Retry successful!');
                                addSystemMessage('üìπ Video connection restored');
                            }).catch(e => {
                                console.error('[WebRTC] ‚ùå Retry failed:', e);
                                addSystemMessage('‚ùå Video playback issues');
                            });
                        }, 100);
                    }
                }, 500);
            }
            
            async initializeMedia(audio = true, video = false) {
                try {
                    const constraints = {
                        audio: audio ? {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 44100
                        } : false,
                        video: video ? {
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            frameRate: { ideal: 15, max: 30 },
                            facingMode: 'user'
                        } : false
                    };
                    
                    console.log('[WebRTC] üì∏ Requesting media access...');
                    this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    console.log('[WebRTC] ‚úÖ Media access granted');
                    console.log('[WebRTC] Tracks:', this.localStream.getTracks().map(t => `${t.kind}: ${t.label}`));
                    
                    // Display local video
                    const localVideo = document.getElementById('localVideo');
                    if (localVideo && this.localStream) {
                        localVideo.srcObject = this.localStream;
                        localVideo.play().catch(e => console.log('[WebRTC] Local video play error:', e));
                    }
                    
                    // Add tracks to peer connection
                    if (this.peerConnection) {
                        this.localStream.getTracks().forEach(track => {
                            console.log('[WebRTC] ‚ûï Adding track:', track.kind);
                            this.peerConnection.addTrack(track, this.localStream);
                        });
                        console.log('[WebRTC] ‚úÖ All tracks added to peer connection');
                    }
                    
                    return this.localStream;
                    
                } catch (error) {
                    console.error('[WebRTC] ‚ùå Media initialization failed:', error);
                    addSystemMessage('‚ùå Camera/microphone access denied');
                    throw error;
                }
            }
            
            async startVideoCall() {
                try {
                    console.log('[WebRTC] üöÄ Starting video call...');
                    this.createPeerConnection();
                    await this.initializeMedia(true, true);
                    
                    this.callType = 'video';
                    this.isCallActive = true;
                    this.isCaller = true;
                    
                    // Send call request
                    this.sendMessage({
                        type: 'call_request',
                        call_type: 'video',
                        caller: this.localPeerId
                    });
                    
                    addSystemMessage('üìπ Initiating video call...');
                    this.showMediaPanel();
                    
                } catch (error) {
                    console.error('[WebRTC] ‚ùå Video call failed:', error);
                    addSystemMessage('‚ùå Video call failed: ' + error.message);
                    this.endCall();
                }
            }
            
            async startAudioCall() {
                try {
                    console.log('[WebRTC] üöÄ Starting audio call...');
                    this.createPeerConnection();
                    await this.initializeMedia(true, false);
                    
                    this.callType = 'audio';
                    this.isCallActive = true;
                    this.isCaller = true;
                    
                    this.sendMessage({
                        type: 'call_request',
                        call_type: 'audio',
                        caller: this.localPeerId
                    });
                    
                    addSystemMessage('üìû Initiating audio call...');
                    this.showMediaPanel();
                    
                } catch (error) {
                    console.error('[WebRTC] ‚ùå Audio call failed:', error);
                    addSystemMessage('‚ùå Audio call failed: ' + error.message);
                    this.endCall();
                }
            }
            
            async handleIncomingCall(callData) {
                if (this.isCallActive) {
                    console.log('[WebRTC] üìµ Call declined - already in call');
                    addSystemMessage('üìµ Call declined - already in a call');
                    return;
                }
                
                console.log('[WebRTC] üìû Incoming call from:', callData.caller);
                this.pendingCall = callData;
                this.showCallModal(callData);
            }
            
            async acceptIncomingCall() {
                if (!this.pendingCall || this.callEnded) return;
                
                try {
                    const callData = this.pendingCall;
                    this.pendingCall = null;
                    
                    console.log('[WebRTC] ‚úÖ Accepting call from:', callData.caller);
                    this.createPeerConnection();
                    
                    const isVideo = callData.call_type === 'video';
                    await this.initializeMedia(true, isVideo);
                    
                    this.callType = callData.call_type;
                    this.isCallActive = true;
                    this.isCaller = false;
                    
                    // Send call-accepted signal
                    console.log('[WebRTC] üì° Sending call-accepted signal');
                    this.sendSignalingMessage({
                        type: 'call-accepted',
                        from: this.localPeerId,
                        to: callData.caller,
                        call_type: callData.call_type
                    });
                    
                    addSystemMessage(`‚úÖ Accepted ${callData.call_type} call`);
                    this.showMediaPanel();
                    this.hideCallModal();
                    
                    console.log('[WebRTC] ‚è≥ Waiting for offer...');
                    
                } catch (error) {
                    console.error('[WebRTC] ‚ùå Accept call failed:', error);
                    addSystemMessage('‚ùå Failed to accept call: ' + error.message);
                }
            }
            
            async handleCallAccepted(data) {
                if (!this.isCaller || !this.isCallActive) {
                    console.log('[WebRTC] Ignoring call-accepted - not caller or inactive');
                    return;
                }
                
                try {
                    console.log('[WebRTC] üì° Call accepted! Creating offer...');
                    
                    const offer = await this.peerConnection.createOffer({
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: this.callType === 'video'
                    });
                    
                    await this.peerConnection.setLocalDescription(offer);
                    console.log('[WebRTC] üì§ Sending offer');
                    
                    this.sendSignalingMessage({
                        type: 'offer',
                        offer: offer,
                        from: this.localPeerId,
                        to: data.from
                    });
                    
                    addSystemMessage('üìû Negotiating connection...');
                    
                } catch (error) {
                    console.error('[WebRTC] ‚ùå Failed to create offer:', error);
                    addSystemMessage('‚ùå Failed to create offer');
                }
            }
            
            async handleWebRTCSignaling(data) {
                if (!this.peerConnection || this.callEnded) {
                    console.log('[WebRTC] Ignoring signaling - no peer connection or call ended');
                    return;
                }
                
                console.log('[WebRTC] üì° Processing signaling:', data.type);
                
                try {
                    switch (data.type) {
                        case 'offer':
                            console.log('[WebRTC] üì• Processing offer');
                            await this.peerConnection.setRemoteDescription(data.offer);
                            
                            const answer = await this.peerConnection.createAnswer();
                            await this.peerConnection.setLocalDescription(answer);
                            
                            console.log('[WebRTC] üì§ Sending answer');
                            this.sendSignalingMessage({
                                type: 'answer',
                                answer: answer,
                                from: this.localPeerId,
                                to: data.from
                            });
                            break;
                            
                        case 'answer':
                            console.log('[WebRTC] üì• Processing answer');
                            if (this.signalingState === 'have-local-offer') {
                                await this.peerConnection.setRemoteDescription(data.answer);
                                console.log('[WebRTC] ‚úÖ Answer processed successfully');
                            } else {
                                console.error('[WebRTC] ‚ùå Invalid signaling state for answer:', this.signalingState);
                            }
                            break;
                            
                        case 'ice-candidate':
                            console.log('[WebRTC] üì• Processing ICE candidate');
                            if (this.peerConnection.remoteDescription) {
                                await this.peerConnection.addIceCandidate(data.candidate);
                                console.log('[WebRTC] ‚úÖ ICE candidate added');
                            } else {
                                console.log('[WebRTC] ‚è≥ Queuing ICE candidate');
                            }
                            break;
                            
                        case 'call-accepted':
                            await this.handleCallAccepted(data);
                            break;
                            
                        default:
                            console.log('[WebRTC] ‚ùì Unknown signaling type:', data.type);
                    }
                } catch (error) {
                    console.error('[WebRTC] ‚ùå Signaling error:', error);
                    addSystemMessage('‚ùå Connection error: ' + error.message);
                }
            }
            
            sendSignalingMessage(data) {
                console.log('[WebRTC] üì§ Sending signaling:', data.type);
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify({
                        type: 'webrtc_signal',
                        signal: data
                    }));
                } else {
                    console.error('[WebRTC] ‚ùå WebSocket not ready');
                }
            }
            
            sendMessage(message) {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify(message));
                }
            }
            
            // Media controls
            toggleMute() {
                if (this.localStream) {
                    const audioTrack = this.localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        const muteBtn = document.getElementById('muteBtn');
                        if (muteBtn) {
                            muteBtn.textContent = audioTrack.enabled ? 'üé§' : 'üîá';
                            muteBtn.classList.toggle('muted', !audioTrack.enabled);
                        }
                        addSystemMessage(audioTrack.enabled ? 'üé§ Unmuted' : 'üîá Muted');
                    }
                }
            }
            
            toggleVideo() {
                if (this.localStream) {
                    const videoTrack = this.localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        const videoBtn = document.getElementById('videoBtn');
                        if (videoBtn) {
                            videoBtn.textContent = videoTrack.enabled ? 'üìπ' : 'üìµ';
                            videoBtn.classList.toggle('muted', !videoTrack.enabled);
                        }
                        addSystemMessage(videoTrack.enabled ? 'üìπ Video on' : 'üìµ Video off');
                    }
                }
            }
            
            async shareScreen() {
                try {
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });
                    
                    const videoTrack = screenStream.getVideoTracks()[0];
                    
                    if (this.peerConnection) {
                        const sender = this.peerConnection.getSenders().find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        
                        if (sender) {
                            await sender.replaceTrack(videoTrack);
                        }
                    }
                    
                    videoTrack.onended = () => {
                        addSystemMessage('üñ•Ô∏è Screen sharing ended');
                        const cameraTrack = this.localStream?.getVideoTracks()[0];
                        if (cameraTrack && this.peerConnection) {
                            const sender = this.peerConnection.getSenders().find(s => 
                                s.track && s.track.kind === 'video'
                            );
                            if (sender) {
                                sender.replaceTrack(cameraTrack);
                            }
                        }
                    };
                    
                    addSystemMessage('üñ•Ô∏è Screen sharing started');
                    
                } catch (error) {
                    console.error('[WebRTC] Screen sharing failed:', error);
                    addSystemMessage('‚ùå Screen sharing failed');
                }
            }
            
            endCall() {
                if (this.callEnded) return;
                
                console.log('[WebRTC] üîö Ending call');
                this.callEnded = true;
                this.isCallActive = false;
                this.callType = null;
                this.pendingCall = null;
                this.isCaller = false;
                
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                
                this.hideMediaPanel();
                this.hideCallModal();
                addSystemMessage('üìµ Call ended');
            }
            
            showMediaPanel() {
                const panel = document.getElementById('mediaPanel');
                if (panel) {
                    panel.classList.add('active');
                }
            }
            
            hideMediaPanel() {
                const panel = document.getElementById('mediaPanel');
                if (panel) {
                    panel.classList.remove('active');
                }
                
                // Clear video sources
                const localVideo = document.getElementById('localVideo');
                const remoteVideo = document.getElementById('remoteVideo');
                if (localVideo) localVideo.srcObject = null;
                if (remoteVideo) remoteVideo.srcObject = null;
            }
            
            showCallModal(callData) {
                const modal = document.getElementById('callModal');
                const message = document.getElementById('callModalMessage');
                if (modal && message) {
                    message.textContent = `Incoming ${callData.call_type} call from ${callData.caller}`;
                    modal.classList.add('active');
                }
            }
            
            hideCallModal() {
                const modal = document.getElementById('callModal');
                if (modal) {
                    modal.classList.remove('active');
                }
            }
        }

        // =================================================================
        // GLOBAL VARIABLES AND WEBSOCKET
        // =================================================================

        let websocket = null;
        let reconnectAttempts = 0;
        let webrtcManager = null;

        function initializeWebRTC() {
            webrtcManager = new Metal52WebRTC();
            console.log('[APP] ‚úÖ WebRTC Manager created');
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/chat`;

            websocket = new WebSocket(wsUrl);

            websocket.onopen = function () {
                console.log('[WS] ‚úÖ Connected to Metal-52');
                updateStatus('CONNECTED');
                reconnectAttempts = 0;

                if (webrtcManager) {
                    webrtcManager.setWebSocket(websocket);
                }
            };

            websocket.onmessage = function (event) {
                handleWebSocketMessage(event.data);
            };

            websocket.onclose = function () {
                console.log('[WS] ‚ùå Connection closed');
                updateStatus('DISCONNECTED');
                attemptReconnect();
            };

            websocket.onerror = function (error) {
                console.error('[WS] ‚ùå Error:', error);
                updateStatus('ERROR');
            };
        }

        function handleWebSocketMessage(data) {
            console.log('[WS] üì® Message received:', data.substring(0, 100) + '...');

            try {
                const message = JSON.parse(data);

                switch (message.type) {
                    case 'chat':
                        addMessage(message.sender, message.message, message.timestamp);
                        break;
                    case 'udp_message':
                        addMessage(message.sender, message.message, message.timestamp);
                        break;
                    case 'system':
                        addSystemMessage(message.message);
                        break;
                    case 'error':
                        addSystemMessage(`‚ö†Ô∏è ${message.message}`);
                        break;
                    case 'call_request':
                        console.log('[WS] üìû Call request:', message);
                        if (webrtcManager) {
                            webrtcManager.handleIncomingCall(message);
                        }
                        break;
                    case 'webrtc_signal':
                        console.log('[WS] üì° WebRTC signal:', message.signal?.type);
                        if (webrtcManager) {
                            webrtcManager.handleWebRTCSignaling(message.signal);
                        }
                        break;
                    default:
                        console.log('[WS] ‚ùì Unknown message type:', message.type);
                        addMessage('Network', data);
                }
            } catch (error) {
                console.error('[WS] ‚ùå Message parsing error:', error);
                addMessage('Network', data);
            }
        }

        // =================================================================
        // GLOBAL FUNCTIONS FOR UI INTERACTION
        // =================================================================

        function startAudioCall() {
            console.log('[APP] üé§ Starting audio call');
            if (webrtcManager) {
                webrtcManager.startAudioCall();
            } else {
                addSystemMessage('‚ùå WebRTC not ready');
            }
        }

        function startVideoCall() {
            console.log('[APP] üìπ Starting video call');
            if (webrtcManager) {
                webrtcManager.startVideoCall();
            } else {
                addSystemMessage('‚ùå WebRTC not ready');
            }
        }

        function acceptCall() {
            console.log('[APP] ‚úÖ Accepting call');
            if (webrtcManager) {
                webrtcManager.acceptIncomingCall();
            }
        }

        function declineCall() {
            console.log('[APP] üìµ Declining call');
            if (webrtcManager) {
                webrtcManager.pendingCall = null;
                webrtcManager.hideCallModal();
                addSystemMessage('üìµ Call declined');
            }
        }

        function endCall() {
            if (webrtcManager) {
                webrtcManager.endCall();
            }
        }

        function toggleMute() {
            if (webrtcManager) {
                webrtcManager.toggleMute();
            }
        }

        function toggleVideo() {
            if (webrtcManager) {
                webrtcManager.toggleVideo();
            }
        }

        function shareScreen() {
            if (webrtcManager) {
                webrtcManager.shareScreen();
            }
        }

        // =================================================================
        // UTILITY FUNCTIONS
        // =================================================================

        function updateStatus(status) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = status;
                statusEl.className = status === 'CONNECTED' ? 'status-value online' : 'status-value offline';
            }
        }

        function addMessage(sender, message, timestamp) {
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) return;

            const messageElement = document.createElement('div');
            messageElement.className = 'message';

            const time = timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();

            messageElement.innerHTML = `
                <strong>[${time}] ${escapeHtml(sender)}:</strong> ${escapeHtml(message)}
            `;

            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function addSystemMessage(message) {
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) return;

            const messageElement = document.createElement('div');
            messageElement.className = 'message system-message';

            const timestamp = new Date().toLocaleTimeString();
            messageElement.innerHTML = `
                <strong>[${timestamp}] SYSTEM:</strong> ${escapeHtml(message)}
            `;

            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            if (!input) return;

            const message = input.value.trim();

            if (message && websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(message);
                input.value = '';
            }
        }

        function clearChat() {
            const messagesContainer = document.getElementById('chatMessages');
            if (messagesContainer) {
                messagesContainer.innerHTML = `
                    <div class="message system-message">
                        <strong>[SYSTEM]</strong> Chat history cleared
                    </div>
                `;
            }
        }

        function exportChat() {
            const messages = document.getElementById('chatMessages');
            if (!messages) return;

            const chatData = messages.innerText;
            const blob = new Blob([chatData], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `metal52-chat-node${nodeConfig.node_id}-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function sendFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    addSystemMessage(`üìÅ File selected: ${file.name} (${file.size} bytes)`);
                }
            };
            input.click();
        }

        function emergencyStop() {
            if (confirm('üö® EMERGENCY STOP\n\nThis will terminate all connections. Continue?')) {
                if (webrtcManager) webrtcManager.endCall();
                if (websocket) websocket.close();
                clearChat();
                addSystemMessage('üö® EMERGENCY STOP ACTIVATED');
            }
        }

        function attemptReconnect() {
            if (reconnectAttempts < 5) {
                reconnectAttempts++;
                const delay = Math.pow(2, reconnectAttempts) * 1000;
                setTimeout(connectWebSocket, delay);
            }
        }

        // =================================================================
        // INITIALIZATION
        // =================================================================

        document.addEventListener('DOMContentLoaded', function () {
            console.log('[APP] üöÄ Metal-52 Node', nodeConfig.node_id, 'initializing...');

            // Initialize WebRTC first
            initializeWebRTC();

            // Setup event listeners
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        sendMessage();
                    }
                });
            }

            // Connect WebSocket
            connectWebSocket();

            // Welcome messages
            setTimeout(function () {
                addSystemMessage(`‚úÖ Metal-52 Node ${nodeConfig.node_id} initialized`);
                addSystemMessage('üîê Secure P2P communication ready');
                addSystemMessage('üìû Audio/Video calling available');
                addSystemMessage('üõ°Ô∏è OPSEC-grade encryption active');
            }, 1000);
        });
    </script>
</body>
</html>
